import { JoiValidationConstants } from '@shared/business/entities/JoiValidationConstants';
import { JoiValidationEntity } from '@shared/business/entities/JoiValidationEntity';
import { MAX_FILE_SIZE_BYTES, MAX_FILE_SIZE_MB } from '../EntityConstants';
import { PETITION_TYPES } from '@web-client/presenter/actions/setupPetitionStateAction';
import joi from 'joi';

export class UploadPetitionStep1 extends JoiValidationEntity {
  public acknowledgeChecked: boolean;
  public petitionFile: File;
  public petitionFileSize: number;
  public petitionType: typeof PETITION_TYPES;
  public petitionFacts: string;
  public petitionReasons: string;

  //TODO: Handle generated petition inputs

  constructor(rawProps) {
    super('UploadPetitionStep1');
    this.acknowledgeChecked = rawProps.acknowledgeChecked;
    this.petitionFile = rawProps.petitionFile;
    this.petitionFileSize = rawProps.petitionFileSize;
    this.petitionType = rawProps.petitionType;
    this.petitionFacts = rawProps.petitionFacts;
    this.petitionReasons = rawProps.petitionReasons;
  }

  static VALIDATION_RULES = {
    acknowledgeChecked: joi.boolean().when('petitionType', {
      is: JoiValidationConstants.STRING.valid(PETITION_TYPES.userUploaded),
      otherwise: joi.optional(),
      then: joi.boolean().required().valid(true),
    }),
    //TODO: figure out real max length
    petitionFacts: joi
      .when('petitionType', {
        is: PETITION_TYPES.autoGenerated,
        otherwise: joi.optional(),
        then: joi
          .array()
          .items(JoiValidationConstants.STRING.max(1000))
          .required(),
      })
      .messages({
        '*': 'Facts cannot be empty',
        'number.max': 'Facts cannot exceed 1000 characters',
      }),
    petitionFile: joi.object().when('petitionType', {
      is: JoiValidationConstants.STRING.valid(PETITION_TYPES.userUploaded),
      otherwise: joi.optional(),
      then: joi
        .object()
        .required()
        .messages({ '*': 'Upload the Petition PDF.' }),
    }),
    petitionFileSize: joi
      .number()
      .integer()
      .min(1)
      .max(MAX_FILE_SIZE_BYTES)
      .when('petitionFile', {
        is: joi.exist(),
        otherwise: joi.optional().allow(null),
        then: joi.required(),
      })
      .messages({
        '*': 'Your Petition file size is empty',
        'number.max': `Your Petition file size is too big. The maximum file size is ${MAX_FILE_SIZE_MB}MB.`,
      }),
    petitionReasons: joi
      .when('petitionType', {
        is: PETITION_TYPES.autoGenerated,
        otherwise: joi.optional(),
        then: joi
          .array()
          .items(JoiValidationConstants.STRING.max(1000))
          .required(),
      })
      .messages({
        '*': 'Reasons cannot be empty',
        'number.max': 'Reasons cannot exceed 1000 characters',
      }),
    // TODO: there must be a cleaner way to reference PETITION_TYPES here
    petitionType: joi
      .string()
      .required()
      .valid(PETITION_TYPES.autoGenerated, PETITION_TYPES.userUploaded),
  };

  getValidationRules() {
    return UploadPetitionStep1.VALIDATION_RULES;
  }
}

export type RawUploadPetitionStep1 = ExcludeMethods<
  Omit<UploadPetitionStep1, 'entityName'>
>;
