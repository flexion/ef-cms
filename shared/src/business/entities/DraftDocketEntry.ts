import {
  AMICUS_BRIEF_DOCUMENT_TYPE,
  AUTO_GENERATED_DEADLINE_DOCUMENT_TYPES,
  BRIEF_EVENTCODES,
  CORRECTED_TRANSCRIPT_EVENT_CODE,
  COURT_ISSUED_EVENT_CODES,
  DECISION_EVENT_CODE,
  DOCUMENT_EXTERNAL_CATEGORIES_MAP,
  DOCUMENT_NOTICE_EVENT_CODES,
  DOCUMENT_PROCESSING_STATUS_OPTIONS,
  EXTERNAL_DOCUMENT_TYPES,
  MINUTE_ENTRIES_MAP,
  MOTION_EVENT_CODES,
  OPINION_EVENT_CODES_WITH_BENCH_OPINION,
  ORDER_EVENT_CODES,
  PARTIES_CODES,
  PRACTITIONER_ASSOCIATION_DOCUMENT_TYPES,
  REVISED_TRANSCRIPT_EVENT_CODE,
  ROLES,
  TRACKED_DOCUMENT_TYPES_EVENT_CODES,
  TRANSCRIPT_EVENT_CODE,
  UNSERVABLE_EVENT_CODES,
} from './EntityConstants';
import { DOCKET_ENTRY_VALIDATION_RULES } from './EntityValidationConstants';
import { DocketEntry } from './DocketEntry';
import { JoiValidationEntity } from '@shared/business/entities/JoiValidationEntity';
import { RawUser, User } from './User';
import { UnknownAuthUser } from '@shared/business/entities/authUser/AuthUser';
import { WorkItem } from './WorkItem';
import {
  createISODateAtStartOfDayEST,
  createISODateString,
} from '../../utilities/DateHandler';

type PractitionerRole = 'irsPractitioner' | 'privatePractitioner';

export class DraftDocketEntry extends JoiValidationEntity {
  public action?: string;
  public additionalInfo?: string;
  public additionalInfo2?: string;
  public addToCoversheet?: boolean;
  public archived?: boolean;
  public attachments?: string;
  public caseType?: string;
  public taxYear?: string;
  public noticeIssuedDate?: string;
  public certificateOfService?: boolean;
  public certificateOfServiceDate?: string;
  public createdAt: string;
  public date?: string;
  public docketEntryId: string;
  public docketNumber: string;
  public docketNumbers?: string;
  public documentContentsId?: string;
  public documentIdBeforeSignature?: string;
  public documentTitle: string;
  public documentType: string;
  public eventCode: string;
  public filedBy?: string;
  public filedByRole?: string;
  public filingDate: string;
  public freeText?: string;
  public freeText2?: string;
  public hasOtherFilingParty?: boolean;
  public hasSupportingDocuments?: boolean;
  public index?: number;
  public isAutoGenerated?: boolean;
  public isFileAttached?: boolean;
  public isLegacy?: boolean;
  public editState?: string;
  public isLegacySealed?: boolean;
  public isLegacyServed?: boolean;
  public isOnDocketRecord: boolean;
  public isPaper?: boolean;
  public isPendingService?: boolean;
  public isSealed?: boolean;
  public isStricken?: boolean;
  public lodged?: boolean;
  public mailingDate?: string;
  public numberOfPages?: number;
  public objections?: string;
  public sealedTo?: string;
  public filers: string[];
  public ordinalValue?: string;
  public otherIteration?: string;
  public otherFilingParty?: string;
  public partyIrsPractitioner?: boolean;
  public processingStatus: string;
  public receivedAt: string;
  public relationship?: string;
  public scenario?: string;
  public secondaryDocument?: { secondaryDocumentInfo: string };
  public servedAt?: string;
  public servedPartiesCode?: string;
  public serviceDate?: string;
  public serviceStamp?: string;
  public strickenAt?: string;
  public trialLocation?: string;
  public supportingDocument?: string;
  public userId?: string;
  public privatePractitioners?: any[];
  public servedParties?: any[];
  public signedAt?: string;
  public draftOrderState?: {
    additionalOrderText?: string;
    docketNumber?: string;
    documentTitle?: string;
    documentType?: string;
    dueDate?: string;
    eventCode?: string;
    freeText?: string;
    generatedDocumentTitle?: string;
    issueOrder?: string;
    jurisdiction?: string;
    orderType?: string;
    primaryDocumentFileSize?: number;
    richText?: string;
    scenario?: string;
    statusReportFilingDate?: string;
    statusReportIndex?: string;
    strickenFromTrialSessions?: boolean;
  };

  public stampData!: object;
  public isDraft?: boolean;
  public redactionAcknowledgement?: boolean;
  public judge?: string;
  public judgeUserId?: string;
  public pending?: boolean;
  public previousDocument?: {
    docketEntryId: string;
    documentTitle: string;
    documentType: string;
  };
  public qcAt?: string;
  public qcByUserId?: string;
  public signedByUserId?: string;
  public signedJudgeName?: string;
  public signedJudgeUserId?: string;
  public strickenBy?: string;
  public strickenByUserId?: string;
  public workItem?: any;

  constructor(
    rawDocketEntry,
    {
      applicationContext,
      authorizedUser,
      filtered = false,
    }: {
      authorizedUser?: UnknownAuthUser;
      applicationContext: IApplicationContext;
      petitioners?: any[];
      filtered?: boolean;
    },
  ) {
    super('DocketEntry');
    if (!applicationContext) {
      throw new TypeError('applicationContext must be defined');
    }
    const currentUser = authorizedUser || applicationContext.getCurrentUser();
    if (!filtered || User.isInternalUser(currentUser.role)) {
      this.initForUnfilteredForInternalUsers(rawDocketEntry, {
        applicationContext,
      });
    }
    this.action = rawDocketEntry.action;
    this.additionalInfo = rawDocketEntry.additionalInfo;
    this.additionalInfo2 = rawDocketEntry.additionalInfo2;
    this.addToCoversheet = rawDocketEntry.addToCoversheet || false;
    this.archived = rawDocketEntry.archived;
    this.attachments = rawDocketEntry.attachments;
    this.caseType = rawDocketEntry.caseType;
    this.taxYear = rawDocketEntry.taxYear;
    this.noticeIssuedDate = rawDocketEntry.noticeIssuedDate;
    this.certificateOfService = rawDocketEntry.certificateOfService;
    this.certificateOfServiceDate = rawDocketEntry.certificateOfServiceDate;
    this.createdAt = rawDocketEntry.createdAt || createISODateString();
    this.date = rawDocketEntry.date;
    this.docketEntryId =
      rawDocketEntry.docketEntryId || applicationContext.getUniqueId();
    this.docketNumber = rawDocketEntry.docketNumber;
    this.docketNumbers = rawDocketEntry.docketNumbers;
    this.documentContentsId = rawDocketEntry.documentContentsId;
    this.documentIdBeforeSignature = rawDocketEntry.documentIdBeforeSignature;
    this.documentTitle = rawDocketEntry.documentTitle;
    this.documentType = rawDocketEntry.documentType;
    this.eventCode = rawDocketEntry.eventCode;
    this.filedBy = rawDocketEntry.filedBy;
    this.filedByRole = rawDocketEntry.filedByRole;
    this.filingDate = rawDocketEntry.filingDate || createISODateString();
    this.freeText = rawDocketEntry.freeText;
    this.freeText2 = rawDocketEntry.freeText2;
    this.hasOtherFilingParty = rawDocketEntry.hasOtherFilingParty;
    this.hasSupportingDocuments = rawDocketEntry.hasSupportingDocuments;
    this.index = rawDocketEntry.index;
    this.isAutoGenerated = rawDocketEntry.isAutoGenerated;
    this.isFileAttached = rawDocketEntry.isFileAttached;
    this.isLegacy = rawDocketEntry.isLegacy;
    this.isLegacySealed = rawDocketEntry.isLegacySealed;
    this.isLegacyServed = rawDocketEntry.isLegacyServed;
    this.isOnDocketRecord = rawDocketEntry.isOnDocketRecord || false;
    this.isPaper = rawDocketEntry.isPaper;
    this.isPendingService = rawDocketEntry.isPendingService;
    this.isSealed = rawDocketEntry.isSealed;
    this.isStricken = rawDocketEntry.isStricken || false;
    this.lodged = rawDocketEntry.lodged;
    this.mailingDate = rawDocketEntry.mailingDate;
    this.numberOfPages = rawDocketEntry.numberOfPages;
    this.objections = rawDocketEntry.objections;
    this.redactionAcknowledgement = rawDocketEntry.redactionAcknowledgement;
    this.sealedTo = rawDocketEntry.sealedTo;
    this.filers = rawDocketEntry.filers || [];
    this.ordinalValue = rawDocketEntry.ordinalValue;
    this.otherIteration = rawDocketEntry.otherIteration;
    this.otherFilingParty = rawDocketEntry.otherFilingParty;
    this.partyIrsPractitioner = rawDocketEntry.partyIrsPractitioner;
    this.processingStatus = rawDocketEntry.processingStatus || 'pending';
    this.receivedAt = createISODateAtStartOfDayEST(rawDocketEntry.receivedAt);
    this.relationship = rawDocketEntry.relationship;
    this.scenario = rawDocketEntry.scenario;
    if (rawDocketEntry.scenario === 'Nonstandard H') {
      this.secondaryDocument = rawDocketEntry.secondaryDocument;
    }
    this.servedAt = rawDocketEntry.servedAt;
    this.servedPartiesCode = rawDocketEntry.servedPartiesCode;
    this.serviceDate = rawDocketEntry.serviceDate;
    this.serviceStamp = rawDocketEntry.serviceStamp;
    this.strickenAt = rawDocketEntry.strickenAt;
    this.supportingDocument = rawDocketEntry.supportingDocument;
    this.trialLocation = rawDocketEntry.trialLocation;

    if (currentUser.userId === rawDocketEntry.userId) {
      this.userId = rawDocketEntry.userId;
    }

    if (Array.isArray(rawDocketEntry.privatePractitioners)) {
      this.privatePractitioners = rawDocketEntry.privatePractitioners.map(
        item => {
          return {
            name: item.name,
            partyPrivatePractitioner: item.partyPrivatePractitioner,
          };
        },
      );
    }

    if (DOCUMENT_NOTICE_EVENT_CODES.includes(rawDocketEntry.eventCode)) {
      this.signedAt = rawDocketEntry.signedAt || createISODateString();
    }
  }

  initForUnfilteredForInternalUsers(rawDocketEntry, { applicationContext }) {
    this.editState = rawDocketEntry.editState;
    this.draftOrderState = rawDocketEntry.draftOrderState;
    this.stampData = rawDocketEntry.stampData || {};
    this.isDraft = rawDocketEntry.isDraft || false;
    this.judge = rawDocketEntry.judge;
    this.judgeUserId = rawDocketEntry.judgeUserId;
    this.pending =
      rawDocketEntry.pending === undefined
        ? DocketEntry.isPendingOnCreation(rawDocketEntry)
        : rawDocketEntry.pending;

    if (rawDocketEntry.previousDocument) {
      this.previousDocument = {
        docketEntryId: rawDocketEntry.previousDocument.docketEntryId,
        documentTitle: rawDocketEntry.previousDocument.documentTitle,
        documentType: rawDocketEntry.previousDocument.documentType,
      };
    }

    this.qcAt = rawDocketEntry.qcAt;
    this.qcByUserId = rawDocketEntry.qcByUserId;
    this.signedAt = rawDocketEntry.signedAt;
    this.signedByUserId = rawDocketEntry.signedByUserId;
    this.signedJudgeName = rawDocketEntry.signedJudgeName;
    this.signedJudgeUserId = rawDocketEntry.signedJudgeUserId;
    this.strickenBy = rawDocketEntry.strickenBy;
    this.strickenByUserId = rawDocketEntry.strickenByUserId;
    this.userId = rawDocketEntry.userId;
    this.workItem = rawDocketEntry.workItem
      ? new WorkItem(rawDocketEntry.workItem, { applicationContext })
      : undefined;
  }

  setWorkItem(workItem) {
    this.workItem = workItem;
  }

  archive() {
    this.archived = true;
  }

  setAsServed(servedParties: any[] | null = null) {
    this.servedAt = createISODateString();
    this.draftOrderState = undefined;

    if (this.eventCode === 'ATP') {
      const irsSuperUserParty = [{ name: 'IRS', role: ROLES.irsSuperuser }];
      this.servedParties = irsSuperUserParty;
      this.servedPartiesCode = PARTIES_CODES.RESPONDENT;
      return this;
    }

    if (servedParties) {
      this.servedParties = servedParties;
      this.servedPartiesCode = getServedPartiesCode(servedParties);
    }

    return this;
  }

  shouldAutoGenerateDeadline() {
    return AUTO_GENERATED_DEADLINE_DOCUMENT_TYPES.some(
      item => item.eventCode === this.eventCode,
    );
  }

  getAutoGeneratedDeadlineDescription() {
    return AUTO_GENERATED_DEADLINE_DOCUMENT_TYPES.find(
      item => item.eventCode === this.eventCode,
    )?.deadlineDescription;
  }

  setSigned(signByUserId, signedJudgeName) {
    this.signedByUserId = signByUserId;
    this.signedJudgeName = signedJudgeName;
    this.signedAt = createISODateString();
  }

  unsignDocument() {
    this.signedAt = undefined;
    this.signedJudgeName = undefined;
    this.signedJudgeUserId = undefined;
    this.signedByUserId = undefined;
  }

  setAsProcessingStatusAsCompleted() {
    this.processingStatus = DOCUMENT_PROCESSING_STATUS_OPTIONS.COMPLETE;
  }

  isAutoServed() {
    if (!this.documentType) return false;
    const isExternalDocumentType = EXTERNAL_DOCUMENT_TYPES.includes(
      this.documentType,
    );
    const isPractitionerAssociationDocumentType =
      PRACTITIONER_ASSOCIATION_DOCUMENT_TYPES.includes(this.documentType);

    const isSimultaneous = (this.documentTitle || this.documentType).includes(
      'Simultaneous',
    );

    return (
      (isExternalDocumentType || isPractitionerAssociationDocumentType) &&
      !isSimultaneous
    );
  }

  isCourtIssued(): boolean {
    return DocketEntry.isCourtIssued({ eventCode: this.eventCode });
  }

  static TRANSCRIPT_AGE_DAYS_MIN = 90;

  static isCourtIssued({ eventCode }: { eventCode: string }): boolean {
    return COURT_ISSUED_EVENT_CODES.map(
      ({ eventCode: courtIssuedEventCode }) => courtIssuedEventCode,
    ).includes(eventCode);
  }

  static isPublicEventCode(eventCode: string) {
    return (
      DocketEntry.isOrder(eventCode) ||
      DocketEntry.isDecision(eventCode) ||
      DocketEntry.isOpinion(eventCode) ||
      ['OCS', 'TCRP', 'ODL'].includes(eventCode)
    );
  }

  static isFiledByPractitioner(filedByRole?: string): boolean {
    return (
      !!filedByRole &&
      [ROLES.privatePractitioner, ROLES.irsPractitioner].includes(
        filedByRole as PractitionerRole,
      )
    );
  }

  static isOpinion(eventCode: string): boolean {
    return OPINION_EVENT_CODES_WITH_BENCH_OPINION.includes(eventCode);
  }

  static isOrder(eventCode: string): boolean {
    return ORDER_EVENT_CODES.includes(eventCode);
  }

  static isMotion(eventCode: string): boolean {
    return MOTION_EVENT_CODES.includes(eventCode);
  }

  static isTranscript(eventCode: string): boolean {
    return [
      TRANSCRIPT_EVENT_CODE,
      CORRECTED_TRANSCRIPT_EVENT_CODE,
      REVISED_TRANSCRIPT_EVENT_CODE,
    ].includes(eventCode);
  }

  static isDecision(eventCode: string): boolean {
    return eventCode === DECISION_EVENT_CODE;
  }

  static isBrief(eventCode: string): boolean {
    return BRIEF_EVENTCODES.includes(eventCode);
  }

  static isBriefType(documentType: string): boolean {
    const documentTypes = [
      AMICUS_BRIEF_DOCUMENT_TYPE,
      ...[
        ...DOCUMENT_EXTERNAL_CATEGORIES_MAP['Simultaneous Brief'],
        ...DOCUMENT_EXTERNAL_CATEGORIES_MAP['Seriatim Brief'],
      ].map(document => document.documentType),
    ];
    return !!documentTypes.includes(documentType);
  }

  setNumberOfPages(numberOfPages) {
    this.numberOfPages = numberOfPages;
  }

  setFiledBy(user: RawUser) {
    this.userId = user.userId;
    this.filedByRole = user.role;
  }

  static isPendingOnCreation(rawDocketEntry) {
    return TRACKED_DOCUMENT_TYPES_EVENT_CODES.includes(
      rawDocketEntry.eventCode,
    );
  }

  static isPending(docketEntry) {
    return (
      docketEntry.pending &&
      (DocketEntry.isServed(docketEntry) ||
        UNSERVABLE_EVENT_CODES.find(
          unservedCode => unservedCode === docketEntry.eventCode,
        ))
    );
  }

  getValidationRules() {
    return DOCKET_ENTRY_VALIDATION_RULES;
  }

  static isMinuteEntry({
    eventCode,
    isFileAttached,
  }: {
    eventCode: string;
    isFileAttached?: boolean;
  }): boolean {
    if (eventCode === 'RQT') {
      return !isFileAttached;
    }
    const MINUTE_ENTRIES_EVENT_CODES = Object.values(MINUTE_ENTRIES_MAP).map(
      v => v.eventCode,
    );
    return MINUTE_ENTRIES_EVENT_CODES.includes(eventCode);
  }

  static isUnservable({
    eventCode,
    isLegacyServed,
  }: {
    eventCode: string;
    isLegacyServed?: boolean;
  }): boolean {
    return UNSERVABLE_EVENT_CODES.includes(eventCode) || !!isLegacyServed;
  }

  static fetchRootDocument = (
    entry: RawDocketEntry,
    docketEntries: RawDocketEntry[],
  ): RawDocketEntry => {
    const { previousDocument } = entry;
    if (!previousDocument) return entry;
    const previousEntry = docketEntries.find(
      e => e.docketEntryId === previousDocument.docketEntryId,
    );
    if (!previousEntry) return entry;
    return DocketEntry.fetchRootDocument(previousEntry, docketEntries);
  };
}

export const getServedPartiesCode = (servedParties?: any[]) => {
  let servedPartiesCode: string | undefined = undefined;
  if (servedParties && servedParties.length > 0) {
    if (
      servedParties.length === 1 &&
      servedParties[0].role === ROLES.irsSuperuser
    ) {
      servedPartiesCode = PARTIES_CODES.RESPONDENT;
    } else {
      servedPartiesCode = PARTIES_CODES.BOTH;
    }
  }
  return servedPartiesCode;
};

declare global {
  type RawDraftDocketEntry = ExcludeMethods<DraftDocketEntry>;
}
