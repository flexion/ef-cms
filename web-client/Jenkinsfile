pipeline {

  agent any

  options { 
    buildDiscarder(logRotator(daysToKeepStr: '3', artifactDaysToKeepStr: '3')) 
    disableConcurrentBuilds()
  }

  stages {
    stage('Merge') {
      steps {
        script {
          if (env.branch_name != 'develop' && env.branch_name != 'staging' && env.branch_name != 'master' && env.target_sha1) {
            // todo: there is probably a better way to have Jenkins do this for us automatically
            sh 'git config user.name "EF-CMS Jenkins"'
            sh 'git config user.email "noop@example.com"'
            sh "git merge origin/${env.target_sha1}"
          }
        }
      }
    }
    stage('Init') {
      steps {
        script {
          dir('web-client') {
            sh "./docker-init.sh"
          }
        }
      }
    }
    stage('ShellCheck') {
      steps {
        script {
          dir('web-client') {
            sh "./docker-shellcheck.sh"
          }
        }
      }
    }
    stage('Audit') {
      steps {
        script {
          dir('web-client') {
            sh "./docker-audit.sh"
          }
        }
      }
    }
    stage('Lint') {
      steps {
        script {
          dir('web-client') {
            sh "./docker-lint.sh"
          }
        }
      }
    }
    stage('SonarQube') {
      steps {
        script {
          withCredentials([string(credentialsId: 'UI_SONAR_TOKEN', variable: 'SONAR_TOKEN')]) {
            dir('web-client') {
              sh "SONAR_KEY=${UI_SONAR_KEY} branch_name=${branch_name} SONAR_ORG=${SONAR_ORG} SONAR_TOKEN=${SONAR_TOKEN} ./docker-sonarqube.sh"
            }
          }
        }
      }
    }
    stage('Terraform - Dev') {
      when {
        expression {
          env.branch_name == 'develop'
        }
      }
      steps {
        script {
          dir('web-client') {
            sh "./docker-terraform.sh dev"
          }
        }
      }
    }
    stage('Deploy Dev') {
      when {
        expression {
          env.branch_name == 'develop'
        }
      }
      steps {
        deployTo('dev')
      }
    }
    stage('Terraform - Staging') {
      when {
        expression {
          env.branch_name == 'staging'
        }
      }
      steps {
        script {
          dir('web-client') {
            sh "./docker-terraform.sh stg"
          }
        }
      }
    }
    stage('Deploy Staging') {
      when {
        expression {
          env.branch_name == 'staging'
        }
      }
      steps {
        deployTo('stg')
      }
    }
    stage('Terraform - Prod') {
      when {
        expression {
          env.branch_name == 'master'
        }
      }
      steps {
        script {
          dir('web-client') {
            sh "./docker-terraform.sh prod"
          }
        }
      }
    }
    stage('Deploy Prod') {
      when {
        expression {
          env.branch_name == 'master'
        }
      }
      steps {
        deployTo('prod')
      }
    }
  }
  post {
    always {
      deleteDir()
    }
  }
}

def deployTo(env) {
  dir('web-client') {
    sh "CONTAINER_NAME=ui-dist-${BUILD_NUMBER} ./docker-build.sh ${env}"
    s3Upload(
      bucket: "ui-${env}.${EFCMS_DOMAIN}",
      file: 'dist',
      path: "",
      cacheControl: 'no-cache'
    )
  }
}
