regions = ['us-east-1', 'us-east-2']

branchMap = [
  develop: 'dev',
  staging: 'stg',
  master: 'prod'
]

pipeline {
  agent any

  environment {
    SPAWN_WRAP_SHIM_ROOT = "/home/tomcat"
    npm_config_cache = "/home/tomcat"
    HOME = "/home/tomcat" // needed to running 'npm i' on docker without being root
    CYPRESS_CACHE_FOLDER = "/home/tomcat/cypress_cache" // needed to be able to run cypress without being root
  }

  options { buildDiscarder(logRotator(daysToKeepStr: '3', artifactDaysToKeepStr: '3')) }

  stages {
    stage('Merge') {
      steps {
        script {
          if (env.branch_name != 'develop' && env.branch_name != 'staging' && env.branch_name != 'master' && env.target_sha1) {
            // todo: there is probably a better way to have Jenkins do this for us automatically
            sh 'git config user.name "EF-CMS Jenkins"'
            sh 'git config user.email "noop@example.com"'
            sh "git merge origin/${env.target_sha1}"
          }
        }
      }
    }
    stage('Setup') {
      steps {
        script {
          def runner = docker.build 'setup', '-f document-service/Dockerfile.test .'
          runner.inside('-v /home/tomcat:/home/tomcat -v /etc/passwd:/etc/passwd') {
            dir('document-service') {
              sh 'npm i --no-progress'
            }
          }
        }
      }
    }
    stage('ShellCheck') {
      steps {
        script {
          dir('document-service') {
            def runner = docker.build 'shellcheck', '-f Dockerfile.shellcheck .'
            runner.inside('-v /home/tomcat:/home/tomcat') {
              sh './run-shellcheck.sh'
            }
          }
        }
      }
    }
//    stage('Audit') {
//      steps {
//        script {
//          def runner = docker.build 'setup', '-f document-service/Dockerfile.test .'
//          runner.inside('-v /home/tomcat:/home/tomcat') {
//            dir('document-service') {
//              sh 'npm audit'
//            }
//          }
//        }
//      }
//    }
    stage('Lint') {
      steps {
        script {
          def runner = docker.build 'lint', '-f document-service/Dockerfile.test .'
          runner.inside('-v /home/tomcat:/home/tomcat') {
            dir('document-service') {
              sh 'npm run lint'
            }
          }
        }
      }
    }
    stage('Test') {
      steps {
        script {
          def runner = docker.build 'test', '-f document-service/Dockerfile.test .'
          runner.inside('-v /home/tomcat:/home/tomcat') {
            dir('document-service') {
              sh 'npm run test'
            }
          }
        }
      }
      post {
        success {
          dir('document-service') {
            publishHTML allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'coverage', reportFiles: 'index.html', reportName: 'Code Coverage Report', reportTitles: ''
          }
        }
      }
    }
    stage('SonarQube') {
      steps {
        script {
          withCredentials([string(credentialsId: 'API_SONAR_TOKEN', variable: 'SONAR_TOKEN')]) {
            def runner = docker.build 'sonar', '-f document-service/Dockerfile.sonar .'
            runner.inside("-e GIT_SSH_COMMAND='ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no' -e AWS_DEFAULT_REGION=us-east-1 -v /etc/passwd:/etc/passwd") {
              sshagent(credentials: ['github']) {
                dir('management/management') {
                  sh './deploy-init.sh'
                }
                dir('document-service') {
                  sh './verify-sonarqube-passed.sh'
                }
              }
            }
          }
        }
      }
    }
    stage('Terraform') {
      when {
        expression {
          shouldDeploy(env.branch_name)
        }
      }
      steps {
        script {
          def tasks = createTerraformTasks getTarget(env.branch_name)
          parallel tasks
        }
      }
    }
    stage('Serverless') {
      when {
        expression {
          shouldDeploy(env.branch_name)
        }
      }
      steps {
        script {
          def tasks = createDeployTasks getTarget(env.branch_name)
          parallel tasks
        }
      }
    }
    stage('Setup Active-Active Route53 Regional Record') {
      when {
        expression {
          shouldDeploy(env.branch_name)
        }
      }
      steps {
        script {
          def tasks = createRoute53Tasks getTarget(env.branch_name)
          parallel tasks
        }
      }
    }
    stage('Setup S3 Replication Pre Prod') {
      when {
        expression {
          shouldDeploy(env.branch_name)
        }
      }
      steps {
        script {
          def tasks = createS3ReplicationTasks getTarget(env.branch_name)
          parallel tasks
        }
      }
    }
    stage('Setup Global Tables') {
      when {
        expression {
          shouldDeploy(env.branch_name)
        }
      }
      steps {
        script {
          def tasks = createGlobalTableTasks getTarget(env.branch_name)
          parallel tasks
        }
      }
    }
    stage('Smoke Tests') {
      when {
        expression {
          shouldDeploy(env.branch_name)
        }
      }
      steps {
        script {
          def tasks = createSmokeTestTasks getTarget(env.branch_name)
          parallel tasks
        }
      }
    }
  }
  post {
    always {
      deleteDir()
    }
  }
}

def createRoute53Tasks(targets) {
  def tasks = [:]
  targets.each { deploy ->
    def slsStage = deploy.env
    tasks["${slsStage}"] = {
      node() {
        stage("Route 53 Record ${slsStage}") {
          checkout scm
          def runner = docker.build 'serverless', '-f document-service/Dockerfile.deploy .'
          runner.inside('-v /home/tomcat:/home/tomcat -v /etc/passwd:/etc/passwd') {
            dir("document-service") {
              sh 'npm i --no-progress'
              sh "./setup-regional-route53.sh ${slsStage}"
            }
          }
        }
      }
    }
  }
  return tasks
}

def createS3ReplicationTasks(targets) {
  def tasks = [:]
  targets.each { deploy ->
    def slsStage = deploy.env
    tasks["${slsStage}"] = {
      node() {
        stage("global tables ${slsStage}") {
          checkout scm
          def runner = docker.build 'serverless', '-f document-service/Dockerfile.deploy .'
          runner.inside('-v /home/tomcat:/home/tomcat -v /etc/passwd:/etc/passwd') {
            dir('document-service') {
              sh 'npm i --no-progress'
              sh("./setup-s3-replication.sh ${slsStage}")
            }
          }
        }
      }
    }
  }
  return tasks
}

def createGlobalTableTasks(targets) {
  def tasks = [:]
  targets.each { deploy ->
    def slsStage = deploy.env
    tasks["${slsStage}"] = {
      node() {
        stage("global tables ${slsStage}") {
          checkout scm
          def trunner = docker.build 'globaltables', '-f document-service/Dockerfile.test .'
          trunner.inside('-v /home/tomcat:/home/tomcat -v /etc/passwd:/etc/passwd') {
            dir("document-service") {
              sh 'npm i --no-progress'
              sh "node setup-global-tables.js efcms-documents-${slsStage} ${deploy.regions.join(',')}"
            }
          }
        }
      }
    }
  }
  return tasks
}

def createTerraformTasks(targets) {
  def tasks = [:]
  targets.each { deploy ->
    def slsStage = deploy.env
    tasks["${slsStage}"] = {
      node() {
        stage("terraform ${slsStage}") {
          checkout scm
          def trunner = docker.build 'terraform', '-f document-service/Dockerfile.deploy .'
          trunner.inside() {
            dir("document-service/terraform/main") {
              sh "../bin/deploy-app.sh ${slsStage}"

              script {
                echo 'Setting environment variables based on Terraform run'
                SLS_DEPLOYMENT_BUCKET = sh(script: "terraform output sls_deployment_bucket", returnStdout: true).trim()
              }
            }
          }
        }
      }
    }
  }
  return tasks
}

def createSmokeTestTasks(targets) {
  def tasks = [:]
  targets.each { deploy ->
    def slsStage = deploy.env
    deploy.regions.each { region ->
      tasks["${slsStage} - ${region}"] = {
        node() {
          stage("smoketest ${slsStage} - ${region}") {
            checkout scm
            def runner = docker.build 'serverless', '-f document-service/Dockerfile.deploy .'
            runner.inside('-v /home/tomcat:/home/tomcat -v /etc/passwd:/etc/passwd') {
              dir('document-service') {
                sh 'npm i --no-progress'
                echo 'Running smoke test'
                sh 'mkdir -p coverage'
                def restApiId=sh(script: "aws apigateway get-rest-apis --region=${region} --query \"items[?name=='${slsStage}-ef-cms'].id\" --output text", returnStdout: true).trim()
                sh("API_REGION=${region} API_STAGE=${slsStage} API_TARGET=${restApiId} ./node_modules/.bin/artillery run ./smokeTest.yml --output ./coverage/artillery_smoke_test.json")
                sh("./node_modules/.bin/artillery report -o ./coverage/smokeTestReport.html ./coverage/artillery_smoke_test.json")
              }
            }
          }
        }
      }
    }
  }
  return tasks
}

def createDeployTasks(targets) {
  def deployTasks = [:]
  targets.each { deploy ->
    def slsStage = deploy.env
    deploy.regions.each { region ->
      deployTasks["${slsStage} - ${region}"] = {
        node() {
          stage("serverless ${slsStage} - ${region}") {
            checkout scm
            def runner = docker.build 'serverless', '-f document-service/Dockerfile.deploy .'
            runner.inside('-v /home/tomcat:/home/tomcat -v /etc/passwd:/etc/passwd') {
              dir('document-service') {
                sh 'npm i --no-progress'
                dir('./src') {
                  echo 'Fix file permissions'
                  sh 'find . -type f -exec chmod -R ugo+r {} ";"'
                }
                echo 'Build main site distribution'
                sh "./node_modules/.bin/sls create_domain --stage ${slsStage} --region ${region} --verbose"
                sh "ENVIRONMENT=${slsStage} SLS_DEPLOYMENT_BUCKET=gov.ustaxcourt.ef-cms.apis.${slsStage}.${region}.deploys ./node_modules/.bin/sls deploy --stage ${slsStage} --region ${region} --verbose"
                sh "./configure-custom-api-access-logging.sh ${slsStage} ./config-custom-access-logs.json ${region}"
              }
            }
          }
        }
      }
    }
  }
  return deployTasks
}

def shouldDeploy(branchName) {
  ['develop', 'staging', 'master'].contains(branchName) == true
}

def getTarget(branchName) {
  [
    [env: branchMap[branchName], regions: regions]
  ]
}